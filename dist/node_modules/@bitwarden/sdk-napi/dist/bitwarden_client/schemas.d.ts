/**
 * Basic client behavior settings. These settings specify the various targets and behavior
 * of the Bitwarden Client. They are optional and uneditable once the client is
 * initialized.
 *
 * Defaults to
 *
 * ``` # use bitwarden::sdk::request::client_settings::{ClientSettings, DeviceType}; # use
 * assert_matches::assert_matches; let settings = ClientSettings { identity_url:
 * "https://identity.bitwarden.com".to_string(), api_url:
 * "https://api.bitwarden.com".to_string(), user_agent: "Bitwarden Rust-SDK".to_string(),
 * device_type: DeviceType::SDK, }; let default = ClientSettings::default();
 * assert_matches!(settings, default); ```
 *
 * Targets `localhost:8080` for debug builds.
 */
export interface ClientSettings {
    /**
     * The api url of the targeted Bitwarden instance. Defaults to `https://api.bitwarden.com`
     */
    apiUrl: string;
    /**
     * Device type to send to Bitwarden. Defaults to SDK
     */
    deviceType: DeviceType;
    /**
     * The identity url of the targeted Bitwarden instance. Defaults to
     * `https://identity.bitwarden.com`
     */
    identityUrl: string;
    /**
     * The user_agent to sent to Bitwarden. Defaults to `Bitwarden Rust-SDK`
     */
    userAgent: string;
}
/**
 * Device type to send to Bitwarden. Defaults to SDK
 */
export declare enum DeviceType {
    Android = "Android",
    AndroidAmazon = "AndroidAmazon",
    ChromeBrowser = "ChromeBrowser",
    ChromeExtension = "ChromeExtension",
    EdgeBrowser = "EdgeBrowser",
    EdgeExtension = "EdgeExtension",
    FirefoxBrowser = "FirefoxBrowser",
    FirefoxExtension = "FirefoxExtension",
    IEBrowser = "IEBrowser",
    IOS = "iOS",
    LinuxDesktop = "LinuxDesktop",
    MACOSDesktop = "MacOsDesktop",
    OperaBrowser = "OperaBrowser",
    OperaExtension = "OperaExtension",
    SDK = "SDK",
    SafariBrowser = "SafariBrowser",
    SafariExtension = "SafariExtension",
    UWP = "UWP",
    UnknownBrowser = "UnknownBrowser",
    VivaldiBrowser = "VivaldiBrowser",
    VivaldiExtension = "VivaldiExtension",
    WindowsDesktop = "WindowsDesktop"
}
/**
 * Login with username and password
 *
 * This command is for initiating an authentication handshake with Bitwarden. Authorization
 * may fail due to requiring 2fa or captcha challenge completion despite accurate
 * credentials.
 *
 * This command is not capable of handling authentication requiring 2fa or captcha.
 *
 * Returns: [PasswordLoginResponse](crate::sdk::auth::response::PasswordLoginResponse)
 *
 * Login with API Key
 *
 * This command is for initiating an authentication handshake with Bitwarden.
 *
 * Returns: [ApiKeyLoginResponse](crate::sdk::auth::response::ApiKeyLoginResponse)
 *
 * Login with Secrets Manager Access Token
 *
 * This command is for initiating an authentication handshake with Bitwarden.
 *
 * Returns: [ApiKeyLoginResponse](crate::sdk::auth::response::ApiKeyLoginResponse)
 *
 * > Requires Authentication Get the API key of the currently authenticated user
 *
 * Returns:
 * [UserApiKeyResponse](crate::sdk::response::user_api_key_response::UserApiKeyResponse)
 *
 * > Requires Authentication Retrieve all user data, ciphers and organizations the user is a
 * part of
 *
 * Returns: [SyncResponse](crate::sdk::response::sync_response::SyncResponse)
 */
export interface Command {
    passwordLogin?: PasswordLoginRequest;
    apiKeyLogin?: APIKeyLoginRequest;
    accessTokenLogin?: AccessTokenLoginRequest;
    getUserApiKey?: SecretVerificationRequest;
    sync?: SyncRequest;
    secrets?: SecretsCommand;
    projects?: ProjectsCommand;
}
/**
 * Login to Bitwarden with access token
 */
export interface AccessTokenLoginRequest {
    /**
     * Bitwarden service API access token
     */
    accessToken: string;
}
/**
 * Login to Bitwarden with Api Key
 */
export interface APIKeyLoginRequest {
    /**
     * Bitwarden account client_id
     */
    clientId: string;
    /**
     * Bitwarden account client_secret
     */
    clientSecret: string;
    /**
     * Bitwarden account master password
     */
    password: string;
}
export interface SecretVerificationRequest {
    /**
     * The user's master password to use for user verification. If supplied, this will be used
     * for verification purposes.
     */
    masterPassword?: null | string;
    /**
     * Alternate user verification method through OTP. This is provided for users who have no
     * master password due to use of Customer Managed Encryption. Must be present and valid if
     * master_password is absent.
     */
    otp?: null | string;
}
/**
 * Login to Bitwarden with Username and Password
 */
export interface PasswordLoginRequest {
    /**
     * Bitwarden account email address
     */
    email: string;
    /**
     * Bitwarden account master password
     */
    password: string;
}
/**
 * > Requires Authentication > Requires using an Access Token for login or calling Sync at
 * least once Retrieve a project by the provided identifier
 *
 * Returns: [ProjectResponse](crate::sdk::response::projects_response::ProjectResponse)
 *
 * > Requires Authentication > Requires using an Access Token for login or calling Sync at
 * least once Lists all projects of the given organization
 *
 * Returns: [ProjectsResponse](crate::sdk::response::projects_response::ProjectsResponse)
 */
export interface ProjectsCommand {
    get?: ProjectGetRequest;
    list?: ProjectsListRequest;
}
export interface ProjectGetRequest {
    /**
     * ID of the project to retrieve
     */
    id: string;
}
export interface ProjectsListRequest {
    /**
     * Organization to retrieve all the projects from
     */
    organizationId: string;
}
/**
 * > Requires Authentication > Requires using an Access Token for login or calling Sync at
 * least once Retrieve a secret by the provided identifier
 *
 * Returns: [SecretResponse](crate::sdk::response::secrets_response::SecretResponse)
 *
 * > Requires Authentication > Requires using an Access Token for login or calling Sync at
 * least once Creates a new secret in the provided organization using the given data
 *
 * Returns: [SecretResponse](crate::sdk::response::secrets_response::SecretResponse)
 *
 * > Requires Authentication > Requires using an Access Token for login or calling Sync at
 * least once Lists all secret identifiers of the given organization, to then retrieve each
 * secret, use `CreateSecret`
 *
 * Returns:
 * [SecretIdentifiersResponse](crate::sdk::response::secrets_response::SecretIdentifiersResponse)
 *
 * > Requires Authentication > Requires using an Access Token for login or calling Sync at
 * least once Updates an existing secret with the provided ID using the given data
 *
 * Returns: [SecretResponse](crate::sdk::response::secrets_response::SecretResponse)
 *
 * > Requires Authentication > Requires using an Access Token for login or calling Sync at
 * least once Deletes all the secrets whose IDs match the provided ones
 *
 * Returns:
 * [SecretsDeleteResponse](crate::sdk::response::secrets_response::SecretsDeleteResponse)
 */
export interface SecretsCommand {
    get?: SecretGetRequest;
    create?: SecretCreateRequest;
    list?: SecretIdentifiersRequest;
    update?: SecretPutRequest;
    delete?: SecretsDeleteRequest;
}
export interface SecretCreateRequest {
    key: string;
    note: string;
    /**
     * Organization where the secret will be created
     */
    organizationId: string;
    value: string;
}
export interface SecretsDeleteRequest {
    /**
     * IDs of the secrets to delete
     */
    ids: string[];
}
export interface SecretGetRequest {
    /**
     * ID of the secret to retrieve
     */
    id: string;
}
export interface SecretIdentifiersRequest {
    /**
     * Organization to retrieve all the secrets from
     */
    organizationId: string;
}
export interface SecretPutRequest {
    /**
     * ID of the secret to modify
     */
    id: string;
    key: string;
    note: string;
    /**
     * Organization ID of the secret to modify
     */
    organizationId: string;
    value: string;
}
export interface SyncRequest {
    /**
     * Exclude the subdomains from the response, defaults to false
     */
    excludeSubdomains?: boolean | null;
}
export interface ResponseForAPIKeyLoginResponse {
    /**
     * The response data. Populated if `success` is true.
     */
    data?: APIKeyLoginResponse | null;
    /**
     * A message for any error that may occur. Populated if `success` is false.
     */
    errorMessage?: null | string;
    /**
     * Whether or not the SDK request succeeded.
     */
    success: boolean;
}
export interface APIKeyLoginResponse {
    authenticated: boolean;
    /**
     * Whether or not the user is required to update their master password
     */
    forcePasswordReset: boolean;
    /**
     * TODO: What does this do?
     */
    resetMasterPassword: boolean;
    twoFactor?: APIKeyLoginResponseTwoFactorProviders | null;
}
export interface APIKeyLoginResponseTwoFactorProviders {
    authenticator?: PurpleAuthenticator | null;
    /**
     * Duo-backed 2fa
     */
    duo?: PurpleDuo | null;
    /**
     * Email 2fa
     */
    email?: PurpleEmail | null;
    /**
     * Duo-backed 2fa operated by an organization the user is a member of
     */
    organizationDuo?: PurpleDuo | null;
    /**
     * Presence indicates the user has stored this device as bypassing 2fa
     */
    remember?: PurpleRemember | null;
    /**
     * WebAuthn-backed 2fa
     */
    webAuthn?: PurpleWebAuthn | null;
    /**
     * Yubikey-backed 2fa
     */
    yubiKey?: PurpleYubiKey | null;
}
export interface PurpleAuthenticator {
}
export interface PurpleDuo {
    host: string;
    signature: string;
}
export interface PurpleEmail {
    /**
     * The email to request a 2fa TOTP for
     */
    email: string;
}
export interface PurpleRemember {
}
export interface PurpleWebAuthn {
}
export interface PurpleYubiKey {
    /**
     * Whether the stored yubikey supports near field communication
     */
    nfc: boolean;
}
export interface ResponseForPasswordLoginResponse {
    /**
     * The response data. Populated if `success` is true.
     */
    data?: PasswordLoginResponse | null;
    /**
     * A message for any error that may occur. Populated if `success` is false.
     */
    errorMessage?: null | string;
    /**
     * Whether or not the SDK request succeeded.
     */
    success: boolean;
}
export interface PasswordLoginResponse {
    authenticated: boolean;
    /**
     * The information required to present the user with a captcha challenge. Only present when
     * authentication fails due to requiring validation of a captcha challenge.
     */
    captcha?: CAPTCHAResponse | null;
    /**
     * Whether or not the user is required to update their master password
     */
    forcePasswordReset: boolean;
    /**
     * TODO: What does this do?
     */
    resetMasterPassword: boolean;
    /**
     * The available two factor authentication options. Present only when authentication fails
     * due to requiring a second authentication factor.
     */
    twoFactor?: PasswordLoginResponseTwoFactorProviders | null;
}
export interface CAPTCHAResponse {
    /**
     * hcaptcha site key
     */
    siteKey: string;
}
export interface PasswordLoginResponseTwoFactorProviders {
    authenticator?: FluffyAuthenticator | null;
    /**
     * Duo-backed 2fa
     */
    duo?: FluffyDuo | null;
    /**
     * Email 2fa
     */
    email?: FluffyEmail | null;
    /**
     * Duo-backed 2fa operated by an organization the user is a member of
     */
    organizationDuo?: FluffyDuo | null;
    /**
     * Presence indicates the user has stored this device as bypassing 2fa
     */
    remember?: FluffyRemember | null;
    /**
     * WebAuthn-backed 2fa
     */
    webAuthn?: FluffyWebAuthn | null;
    /**
     * Yubikey-backed 2fa
     */
    yubiKey?: FluffyYubiKey | null;
}
export interface FluffyAuthenticator {
}
export interface FluffyDuo {
    host: string;
    signature: string;
}
export interface FluffyEmail {
    /**
     * The email to request a 2fa TOTP for
     */
    email: string;
}
export interface FluffyRemember {
}
export interface FluffyWebAuthn {
}
export interface FluffyYubiKey {
    /**
     * Whether the stored yubikey supports near field communication
     */
    nfc: boolean;
}
export interface ResponseForSecretDeleteResponse {
    /**
     * The response data. Populated if `success` is true.
     */
    data?: SecretDeleteResponse | null;
    /**
     * A message for any error that may occur. Populated if `success` is false.
     */
    errorMessage?: null | string;
    /**
     * Whether or not the SDK request succeeded.
     */
    success: boolean;
}
export interface SecretDeleteResponse {
    error?: null | string;
    id: string;
}
export interface ResponseForSecretIdentifierResponse {
    /**
     * The response data. Populated if `success` is true.
     */
    data?: SecretIdentifierResponse | null;
    /**
     * A message for any error that may occur. Populated if `success` is false.
     */
    errorMessage?: null | string;
    /**
     * Whether or not the SDK request succeeded.
     */
    success: boolean;
}
export interface SecretIdentifierResponse {
    id: string;
    key: string;
    organizationId: string;
}
export interface ResponseForSecretIdentifiersResponse {
    /**
     * The response data. Populated if `success` is true.
     */
    data?: SecretIdentifiersResponse | null;
    /**
     * A message for any error that may occur. Populated if `success` is false.
     */
    errorMessage?: null | string;
    /**
     * Whether or not the SDK request succeeded.
     */
    success: boolean;
}
export interface SecretIdentifiersResponse {
    data: DatumElement[];
}
export interface DatumElement {
    id: string;
    key: string;
    organizationId: string;
}
export interface ResponseForSecretResponse {
    /**
     * The response data. Populated if `success` is true.
     */
    data?: SecretResponse | null;
    /**
     * A message for any error that may occur. Populated if `success` is false.
     */
    errorMessage?: null | string;
    /**
     * Whether or not the SDK request succeeded.
     */
    success: boolean;
}
export interface SecretResponse {
    creationDate: string;
    id: string;
    key: string;
    note: string;
    object: string;
    organizationId: string;
    projectId?: null | string;
    revisionDate: string;
    value: string;
}
export interface ResponseForSecretsDeleteResponse {
    /**
     * The response data. Populated if `success` is true.
     */
    data?: SecretsDeleteResponse | null;
    /**
     * A message for any error that may occur. Populated if `success` is false.
     */
    errorMessage?: null | string;
    /**
     * Whether or not the SDK request succeeded.
     */
    success: boolean;
}
export interface SecretsDeleteResponse {
    data: DatumClass[];
}
export interface DatumClass {
    error?: null | string;
    id: string;
}
export interface ResponseForSyncResponse {
    /**
     * The response data. Populated if `success` is true.
     */
    data?: SyncResponse | null;
    /**
     * A message for any error that may occur. Populated if `success` is false.
     */
    errorMessage?: null | string;
    /**
     * Whether or not the SDK request succeeded.
     */
    success: boolean;
}
export interface SyncResponse {
    /**
     * List of ciphers accesible by the user
     */
    ciphers: CipherDetailsResponse[];
    /**
     * Data about the user, including their encryption keys and the organizations they are a
     * part of
     */
    profile: ProfileResponse;
}
export interface CipherDetailsResponse {
}
/**
 * Data about the user, including their encryption keys and the organizations they are a
 * part of
 */
export interface ProfileResponse {
    email: string;
    id: string;
    name: string;
    organizations: ProfileOrganizationResponse[];
}
export interface ProfileOrganizationResponse {
    id: string;
}
export interface ResponseForUserAPIKeyResponse {
    /**
     * The response data. Populated if `success` is true.
     */
    data?: UserAPIKeyResponse | null;
    /**
     * A message for any error that may occur. Populated if `success` is false.
     */
    errorMessage?: null | string;
    /**
     * Whether or not the SDK request succeeded.
     */
    success: boolean;
}
export interface UserAPIKeyResponse {
    /**
     * The user's API key, which represents the client_secret portion of an oauth request.
     */
    apiKey: string;
}
export declare class Convert {
    static toClientSettings(json: string): ClientSettings;
    static clientSettingsToJson(value: ClientSettings): string;
    static toCommand(json: string): Command;
    static commandToJson(value: Command): string;
    static toResponseForAPIKeyLoginResponse(json: string): ResponseForAPIKeyLoginResponse;
    static responseForAPIKeyLoginResponseToJson(value: ResponseForAPIKeyLoginResponse): string;
    static toResponseForPasswordLoginResponse(json: string): ResponseForPasswordLoginResponse;
    static responseForPasswordLoginResponseToJson(value: ResponseForPasswordLoginResponse): string;
    static toResponseForSecretDeleteResponse(json: string): ResponseForSecretDeleteResponse;
    static responseForSecretDeleteResponseToJson(value: ResponseForSecretDeleteResponse): string;
    static toResponseForSecretIdentifierResponse(json: string): ResponseForSecretIdentifierResponse;
    static responseForSecretIdentifierResponseToJson(value: ResponseForSecretIdentifierResponse): string;
    static toResponseForSecretIdentifiersResponse(json: string): ResponseForSecretIdentifiersResponse;
    static responseForSecretIdentifiersResponseToJson(value: ResponseForSecretIdentifiersResponse): string;
    static toResponseForSecretResponse(json: string): ResponseForSecretResponse;
    static responseForSecretResponseToJson(value: ResponseForSecretResponse): string;
    static toResponseForSecretsDeleteResponse(json: string): ResponseForSecretsDeleteResponse;
    static responseForSecretsDeleteResponseToJson(value: ResponseForSecretsDeleteResponse): string;
    static toResponseForSyncResponse(json: string): ResponseForSyncResponse;
    static responseForSyncResponseToJson(value: ResponseForSyncResponse): string;
    static toResponseForUserAPIKeyResponse(json: string): ResponseForUserAPIKeyResponse;
    static responseForUserAPIKeyResponseToJson(value: ResponseForUserAPIKeyResponse): string;
}
